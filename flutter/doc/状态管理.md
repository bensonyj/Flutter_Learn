## 状态管理

读[Vadaski](https://juejin.im/user/5b5d45f4e51d453526175c06/posts) 状态管理有感

### Scoped Model

[原文链接](https://juejin.im/post/5b97fa0d5188255c5546dcf8)

Scoped_model是一个dart第三方库，提供了让您能够轻松地将**数据模型**从父Widget传递到它的后代的功能。此外，它还会在模型**更新时重新渲染**使用该模型的所有子项。

它直接来自于Google正在开发的新系统Fuchsia核心Widgets 中对Model类的简单提取，作为独立使用的独立Flutter插件发布。

#### 使用方式

##### 添加依赖

在pubspec中添加scoped_model依赖

##### 创建model

```dart
import 'package:scoped_model/scoped_model.dart';

class CountModel extends Model{
  int _count = 0;
  get count => _count;
  
  void increment(){
    _count++;
    notifyListeners();
  }
}

// 自定义的CountModel继承Model
// 在状态发生变化时（increment）通知所有用到了该model的子项更新状态。(notifyListeners)
```

#####将model放到子页面父级或者放到顶层入口处

```dart
//创建顶层状态
  CountModel countModel = CountModel();

  @override
  Widget build(BuildContext context) {
    return ScopedModel<CountModel>(
      model: countModel,
      child: new MaterialApp(
        home: TopScreen(),
      ),
    );
  }
```

#####在子页面获取model

```dart
// 有2中方式
// 第一种使用ScopedModelDescendant获取
@override
  Widget build(BuildContext context) {
    return ScopedModelDescendant<CountModel>(
      builder: (context,child,model){
        return Scaffold(
          body: Center(
            child: Text(
              model.count.toString(),
              style: TextStyle(fontSize: 48.0),
            ),
          ),
        );
      },
    );
  }
// rebuildOnChange属性能够控制当该状态发生变化时，是否rebuild，作用等同于setState。也就是说我们调用改变状态的一些方法时，不必再setState

// 第二种使用使用ScopedModel.of
final countModel = ScopedModel.of<CountModel>(context);
countModel.increment();

// 或者在Model中重写of方法
class CountModel extends Model{
  int _count = 0;
  get count => _count;

  void increment(){
    _count++;
    notifyListeners();
  }
//重写of方法
  CountModel of(context) =>
      ScopedModel.of<CountModel>(context);
}

// 然后直接通过CountModel获取model实例
final countModel2 = CountModel().of(context);

// 我们在使用第二种方式的时候，rebuildOnChange属性默认为false
// final countModel = ScopedModel.of<CountModel>(context,rebuildOnChange: true);
```

#### 注意

##### 如何监听多个model

使用Mixin

```dart
class MainModel extends Model with AModel,BModel,CModel{}
```

然后将MainModel放在顶层即可。 这里有一个比较完整的使用ScopedModel[管理状态的应用](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FHxBreak%2Fnew_trend)，详细用法可参考该项目。

##### 侵入性

由于Model必须继承至Model类，所以它就具有了侵入性。以后假如不用scoped进行状态管理那么必然会带来需要更改多处代码的情况

### Redux

[原文链接](https://juejin.im/post/5ba26c086fb9a05ce57697da)

Redux是一种**单向数据流**架构，可以轻松开发，维护和测试应用程序。

![img](https://user-gold-cdn.xitu.io/2018/9/23/16604bd03c18a1a0?imageView2/0/w/1280/h/960/ignore-error/1)

- 我们在Redux中，所有的状态都储存在**Store**里。这个**Store**会放在App顶层。
- **View**拿到Store储存的状态(State)并把它映射成视图。View还会与用户进行交互，用户点击按钮滑动屏幕等等，这时会因为交互需要数据发生改变。
- Redux让我们不能让View直接操作数据，而是通过发起一个**action**来告诉**Reducer**，状态得改变啦。
- 这时候**Reducer**接收到了这个**action**，他就回去遍历action表，然后找到那个匹配的action，根据action**生成新的状态**并把新的状态放到Store中。
- Store丢弃了老的状态对象，储存了新的状态对象后，就通知所有使用到了这个状态的View更新（类似setState）。这样我们就能够同步不同view中的状态了。

#### 使用方式

##### 添加依赖

原生官网的是[redux](https://link.juejin.im/?target=https%3A%2F%2Fpub.dartlang.org%2Fpackages%2Fredux%23-installing-tab-) ，但是一般都用[flutter_redux](https://link.juejin.im/?target=https%3A%2F%2Fpub.dartlang.org%2Fpackages%2Fflutter_redux) ，flutter_redux是用来简化redux的使用的。

##### 创建State

我们刚才介绍了Redux的流程，状态是由**reducer生成并储存在Store**里面的。Store更新状态的时候，并**不是更改原来的状态对象**，而是直接将reducer生成的新的状态对象**替换**掉老的状态对象。所以，我们的状态应该是immutable的。

```dart
import 'package:meta/meta.dart';
/**
 * State中所有属性都应该是只读的
 */
@immutable
class CountState{
  int _count;
  get count => _count;

  CountState(this._count);
}
```

##### 创建action

```dart
/**
 * 定义操作该State的全部Action
 * 这里只有增加count一个动作
 */
enum Action{
  increment
}
```

##### 创建reducer

```dart
/**
 * reducer会根据传进来的action生成新的CountState
 */
CountState reducer(CountState state,action){
  //匹配Action
    if(action == Action.increment){
      return CountState(state.count+1);
    }
    return state;
}
```

##### 创建store

```dart
// 这段代码写在State中
CountState.initState(){ _count = 0;}

// 应用顶层
void main() {
  final store =
      Store<CountState>(reducer, initialState: CountState.initState());
  runApp(new MyApp(store));
}
```

##### 将store放入顶层

```dart
class MyApp extends StatelessWidget {
  final Store<CountState> store;

  MyApp(this.store);

  @override
  Widget build(BuildContext context) {
    return StoreProvider<CountState>(
      store: store,
      child: new MaterialApp(
        title: 'Flutter Demo',
        theme: new ThemeData(
          primarySwatch: Colors.blue,
        ),
        home: TopScreen(),
      ),
    );
  }
}
```

##### 在子页面中获取Store中的state

```dart
StoreConnector<CountState,int>(
              converter: (store) => store.state.count,
              builder: (context, count) {
                return Text(
                  count.toString(),
                  style: Theme.of(context).textTheme.display1,
                );
              },
            ),
```

##### 发出Action

```dart
floatingActionButton: StoreConnector<CountState,VoidCallback>(
        converter: (store) {
          return () => store.dispatch(Action.increment);
        },
        builder: (context, callback) {
          return FloatingActionButton(
            onPressed: callback,
            child: Icon(Icons.add),
          );
        },
      ),
```

#### 注意

##### ViewModel性能优化

在ViewModel中重写[==] and [hashCode] 方法，然后把distinct属性设为true

##### 处理异步数据

Redux提供了一种简单的方法来更新应用程序的状态以响应同步操作。但是，它缺少处理异步代码的工具。我们如何应对异步相应呢。

这里就需要一个interrupt来处理异步请求，然后再发出新的action通知reducer生成新的State了。 这里有brianegan大神写的另外一个帮助在flutter中使用redux处理异步请求的库[redux_thunk](https://link.juejin.im/?target=https%3A%2F%2Fpub.dartlang.org%2Fpackages%2Fredux_thunk)。我会在之后的文章中详细介绍如何在redux中处理异步操作。

##### redux是否适合flutter

相对于前端开发者来说，如果有过redux经验，推荐使用flutter中的redux，毕竟redux也是相对成熟。

但是在常规应用中，且无redux使用经验的，使用scoped_model相对轻松。

### BLoc

[原文链接](https://juejin.im/post/5bb6f344f265da0aa664d68a)

在使用BLoc前先了解下dart:stream,请翻阅这篇[什么是Stream](https://juejin.im/post/5baa4b90e51d450e6d00f12e)

#### Stream

工厂模式，先入先出，通常通过`StreamController`创建流，以`sink`作为流入口，以`add`作为流添加，流出口就是`stream`，使用`listen`来监听流出口内容。

##### 获得Stream

- 通过构造函数
- 使用StreamController
- IO Stream

stream有三个构造方法：

- **Stream.fromFuture**:从Future创建新的单订阅流,当future完成时将触发一个data或者error，然后使用Down事件关闭这个流。
- **Stream.fromFutures**:从一组Future创建一个单订阅流，每个future都有自己的data或者error事件，当整个Futures完成后，流将会关闭。如果Futures为空，流将会立刻关闭。
- **Stream.fromIterable**:创建从一个集合中获取其数据的单订阅流。

##### 监听Stream

监听一个流最常见的方法就是listen。当有事件发出时，流将会通知listener。Listen方法提供了这几种触发事件：

- onData(必填)：收到数据时触发
- onError：收到Error时触发
- onDone：结束时触发
- unsubscribeOnError：遇到第一个Error时是否取消订阅，默认为false

##### StreamController

```dart
StreamController controller = StreamController();

//监听这个流的出口，当有data流出时，打印这个data
StreamSubscription subscription =
controller.stream.listen((data)=>print("$data"));

controller.sink.add(123);
// 输出:123
```

##### 转换流

- where：`stream.where((event){...})` 
- take: `stream.take(4);`
- transform: `transform()` 配合`StreamTransformer` 使用

##### 流订阅

- 单订阅：单个订阅流在流的整个生命周期内仅允许有一个listener。它在有收听者之前不会生成事件，并且在取消收听时它会停止发送事件，即使你仍然在Sink.add更多事件
- 多订阅：即广播流，广播流允许任意数量的收听者，且无论是否有收听者，他都能产生事件。所以中途进来的收听者将**不会收到**之前的消息。

#### BLoc介绍

BLoC是一种利用reactive programming方式构建应用的方法，这是一个由流构成的完全异步的世界。

![img](https://user-gold-cdn.xitu.io/2018/10/10/1665dfc035e7bd0b?imageView2/0/w/1280/h/960/ignore-error/1)

- 用StreamBuilder包裹有状态的部件，streambuilder将会监听一个流
- 这个流来自于BLoC
- 有状态小部件中的数据来自于监听的流。
- 用户交互手势被检测到，产生了事件。例如按了一下按钮。
- 调用bloc的功能来处理这个事件
- 在bloc中处理完毕后将会把最新的数据add进流的sink中
- StreamBuilder监听到新的数据，产生一个新的snapshot，并重新调用build方法
- Widget被重新构建

BLoC能够允许我们完美的分离业务逻辑！再也不用考虑什么时候需要刷新屏幕了,一切交给StreamBuilder和BLoC!和StatefulWidget说拜拜！！

BLoC代表业务逻辑组件（Business Logic Component），由来自Google的两位工程师 Paolo Soares和Cong Hui设计，并在2018年DartConf期间（2018年1月23日至24日）首次展示。[点击观看Youtube视频。](https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DPLHln7wHgPE)。

#### 使用方式

##### 创建BLoc

```dart
import 'dart:async';

class CountBLoC {
 int _count;
 StreamController<int> _countController;

 CountBLoC() {
   _count = 0;
   _countController = StreamController<int>();
   // 多页面监听使用广播流
   // _countController = StreamController.broadcast<int>();
 }
 
 Stream<int> get value => _countController.stream;

 increment() {
   _countController.sink.add(++_count);
 }

 dispose() {
   _countController.close();
 }
}
```

##### 创建BLoc实例

有三种方式创建bloc

- 全局单例创建：全局单例我们只需要在bloc类的文件中创建一个bloc实例即可

- 局部创建

- scoped：需要借助InheritWidget,实现of方法并让updateShouldNotify返回true。

  ```dart
  class BlocProvider extends InheritedWidget {
    CountBLoC bLoC = CountBLoC();
  
    BlocProvider({Key key, Widget child}) : super(key: key, child: child);
  
    @override
    bool updateShouldNotify(_) => true;
  
    static CountBLoC of(BuildContext context) =>
        (context.inheritFromWidgetOfExactType(BlocProvider) as BlocProvider).bLoC;
  }
  ```

由于我们需要在两个屏幕中访问同一个bloc，所以我们只能选择全局单例模式或者scoped模式。

##### 在页面中使用StreamController

```dart
StreamBuilder<int>(
            stream: bloc.value,
            initialData: 0,
            builder: (BuildContext context, AsyncSnapshot<int> snapshot) {
              return Text(
                'You hit me: ${snapshot.data} times',
                style: Theme.of(context).textTheme.display1,
              );
            })
```

- StreamBuilder中stream参数代表了这个stream builder监听的流，我们这里监听的是countBloc的value（它是一个stream）。
- initData代表初始的值，因为当这个控件首次渲染的时候，还未与用户产生交互，也就不会有事件从流中流出。所以需要给首次渲染一个初始值。
- builder函数接收一个位置参数BuildContext 以及一个snapshot。snapshot就是这个流输出的数据的一个快照。我们可以通过snapshot.data访问快照中的数据。也可以通过snapshot.hasError判断是否有异常，并通过snapshot.error获取这个异常。
- StreamBuilder中的builder是一个AsyncWidgetBuilder，它能够异步构建widget，当检测到有数据从流中流出时，将会重新构建。

##### 在子页面使用

```dart
floatingActionButton: FloatingActionButton(
          onPressed: ()=> bloc.increment(),
          child: Icon(Icons.add),
      )
```

### RxDart

[原文链接](https://juejin.im/post/5bcea438e51d4536c65d2232)

它极大的扩展了Stream的功能,能够让我们在使用bloc的时候更加游刃有余。

- Subject实现并扩展了StreamController,它符合StreamController的所有规范。假如您之前使用的StreamController,那么你可以直接替换为Subject。你可以把它想像成streamController。
- Observable实现并扩展了Stream。它将常用的stream和streamTransformer组合成了非常好用的api。你可以把它想像成stream。

#### 可观察对象--Observable

##### 通过Future创建：fromFuture

```dart
var obs = Observable.fromFuture(new Future.value("Hello"));
obs.listen(print); 
// 输出：Hello
```

##### 通过Iterable创建：fromIterable

```dart
var obs = Observable.fromInterable([1,2,3,4,5]);
obs.listen(print);
// 输出：1 2 3 4 5
```

##### 让流的“吐”出间隔一段时间：interval

```dart
var obs = Observable(Stream.fromIterable([1,2,3,4,5]))
    .interval(new Duration(seconds: 1));
obs.listen(print);
// 输出：1 ... 2 ... 3 ... 4 ... 5
// 其中...代表停顿了一秒。
```

##### 迭代地处理数据：map

```dart
var obs = Observable(Stream.fromIterable([1,2,3,4,5]))
    .map((item)=>++item);
obs.listen(print);
// 输出：2 3 4 5 6
```

##### 扩展流：expand

```dart
var obs = Observable(Stream.fromIterable([1,2,3,4,5]))
   .expand((item)=> [item,item.toDouble()]);
obs.listen(print);
// 输出：1 1.0 2 2.0 3 3.0 4 4.0 5 5.0
```

##### 合并流：merge

```dart
var obs = Observable.merge([
    Stream.fromIterable([1,2,3]),
    Stream.fromIterable([4,5,6]),
    Stream.fromIterable([7,8,9]),
  ]);
obs.listen(print);
// 输出：1 4 7 2 5 8 3 6 9
```

##### 顺序执行多个流：concat

```dart
var obs = Observable.concat([
    Stream.fromIterable([1,2,3]),
    Stream.fromIterable([4,5,6]),
    Stream.fromIterable([7,8,9]),
  ]);
obs.listen(print);
// 输出：1 2 3 4 5 6 7 8 9
```

##### 检查每一个item：every

every会检查每个item是否符合要求，然后它将会返回一个能够被转化为 Observable 的 AsObservableFuture< bool>。

```dart
var obs = Observable.fromIterable([1,2,3,4,5]);
obs.every((x)=> x < 10).asObservable().listen(print);
// 输出结果：true
```

##### 注意

- Dart中 Observables 默认是**单一订阅**。如果您尝试两次收听它，则会抛出 StateError 。你可以使用工厂方法或者 **asBroadcastStream**将其转化为多订阅流。

```dart
  var obs = Observable(Stream.fromIterable([1,2,3,4,5])).asBroadcastStream();
```

- 很多方法的返回值并不是一个 **Single**也不是一个 **Observable**而是必须返回一个Dart的 **Future**。幸运的是你很容易找到一些方法，把他们转化成回 **stream**。
- 出现错误时，Dart中的Stream不会默认关闭。但是在Rxdart中，Error会导致Observable终止，除非它被运算符拦截。
- 默认情况下Dart中Stream是异步的，而Observables默认是同步的。
- 在处理多订阅Observable的时候，onListen方法只有在第一次会被调用。且各个订阅者之间不会互相干涉。

#### 增强版StreamController--Subject

##### 普通广播流控制器：PublishSubject

PublishSubject就是一个普通广播版StreamController，你可以多次收听，默认是sync是false，也就是说里面是一个**AsyncBroadcastStreamController** 异步广播流。

##### 缓存最新一次事件的广播流控制器：BehaviorSubject

BehaviorSubject也是一个广播流，但是它能记录下最新一次的事件，并在新的收听者收听的时候将记录下的事件作为第一帧发送给收听者。

```dart
  final subject = new BehaviorSubject<int>();

  subject.add(1);
  subject.add(2);
  subject.add(3);

  subject.stream.listen(print); // prints 3
  subject.stream.listen(print); // prints 3
  subject.stream.listen(print);
	// 输出：3 3 3
```

##### 缓存更多事件的广播流控制器：ReplaySubject

ReplaySubject能够缓存更多的值，默认情况下将会缓存所有值，并在新的收听的时候将记录下的事件作为第一帧发送给收听者。

```dart
  final subject = ReplaySubject<int>();
  subject.add(1);
  subject.add(2);
  subject.add(3);
  
  subject.stream.listen(print); // prints 1
  subject.stream.listen(print); // prints 1
  subject.stream.listen(print);
  // 输出：1 1 1 2 2 2 3 3 3
```

你还可以通过maxSize控制缓存个数

##### Subject的释放

当你不再收听Subject，或者Subject不再使用时，请务必释放它。你可以调用subscription的cancel()方法让某个听众取消收听，或者Subject.close()，关闭整个流。

### ~~Provide~~

[原文链接](https://juejin.im/post/5c6d4b52f265da2dc675b407)

[Provide](https://pub.dev/packages/provide)被设计为Scope_model的替代品，允许我们更加灵活地处理数据类型和数据。

和Scoped_model一样，Provide也是借助了InheritWidget，将共享状态放到顶层MaterialApp之上。底层部件通过Provier获取该状态，并通过混合ChangeNotifier通知依赖于该状态的组件刷新。

Provide还提供了Provide.stream，让我们能够以处理流的方式处理数据，不过目前还有一些问题，不推荐使用。

provide 在 2019 Google IO大会上已经宣布弃用，现在官方推荐的是一个和这个很相似的库 Provider [![https://github.com/rrousselGit/provider](https://b-gold-cdn.xitu.io/v3/static/img/pin-url-link.3f843e8.svg)github.com/rrousselGit/pr...](https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FrrousselGit%2Fprovider)

### Provider

[Provider](https://pub.dev/packages/provider) 使用方式与provide差不多，直接看例子使用即可。

### 总结

各个模式都有适用场景，粗略看起来：

- redux之类适合中大型应用，需要各个业务线分离
- scoped_model适合个人项目，入门也简单
- BloC适合人员少的项目，且配合RxDart能显著减少业务代码



